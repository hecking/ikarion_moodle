// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var angular, clearDragAndDropTransferObject, collectDraggableInformation, currentDragAndDropTransferObject, draggableDirective, dropAllowedStateClass, droppableDirective, dummy, getDragAndDropTransferObject, isDropped, setDragAndDropTransferObject, showDropAllowedState, showDropNotAllowedState, startShowDropAllowedState, stopShowDropAllowedState;

  window.ut = window.ut || {};

  ut.commons = ut.commons || {};

  angular = window.angular;

  dropAllowedStateClass = "dropObjectOutSideDropArea";

  startShowDropAllowedState = function(element) {
    return showDropNotAllowedState(element);
  };

  stopShowDropAllowedState = function(element) {
    return showDropAllowedState(element);
  };

  isDropped = function(element) {
    return !element.hasClass(dropAllowedStateClass);
  };

  showDropNotAllowedState = function(element) {
    if (!element.hasClass("ui-dialog")) {
      return element.addClass(dropAllowedStateClass);
    }
  };

  showDropAllowedState = function(element) {
    return element.removeClass(dropAllowedStateClass);
  };

  currentDragAndDropTransferObject = null;

  setDragAndDropTransferObject = function(dragAndDropTransferObject) {
    return currentDragAndDropTransferObject = dragAndDropTransferObject;
  };

  getDragAndDropTransferObject = function() {
    return currentDragAndDropTransferObject;
  };

  clearDragAndDropTransferObject = function() {
    return currentDragAndDropTransferObject = null;
  };

  collectDraggableInformation = function(dropElement, element, attributes) {
    var dropAreaOffset, dropObjectId, dropObjectType, dropTargetType, info, objectDropLocation, objectOffset;
    dropObjectType = dropElement.attr("objectType");
    dropObjectId = dropElement.attr("objectId");
    dropAreaOffset = element.offset();
    objectOffset = dropElement.offset();
    objectDropLocation = {
      left: objectOffset.left - dropAreaOffset.left,
      top: objectOffset.top - dropAreaOffset.top
    };
    info = {
      dropObjectType: dropObjectType,
      dropObjectId: dropObjectId,
      objectDropLocation: objectDropLocation,
      dragAndDropTransferObject: getDragAndDropTransferObject()
    };
    if (attributes) {
      dropTargetType = ut.commons.utils.getAttributeValue(attributes, "dropTargetType");
      if (dropTargetType) {
        info.dropTargetType = dropTargetType;
      }
    }
    return info;
  };

  dummy = {
    helper: null,
    objectDraggingStarted: null,
    objectDraggingStopped: null,
    getDragAndDropTransferObject: null,
    objectDroppedOutside: null
  };

  draggableDirective = function() {
    return {
      restrict: "A",
      link: function(scope, element, attrs) {
        var addSpecifiedAttributeValue, dragOptions, originalZIndex,
          _this = this;
        dragOptions = {};
        addSpecifiedAttributeValue = function(name, defaultValue) {
          var lcName;
          lcName = name.toLowerCase();
          if (attrs[lcName]) {
            return dragOptions[name] = attrs[lcName];
          } else if (defaultValue) {
            return dragOptions[name] = defaultValue;
          }
        };
        addSpecifiedAttributeValue("helper");
        addSpecifiedAttributeValue("revert");
        addSpecifiedAttributeValue("revertDuration");
        originalZIndex = null;
        dragOptions.start = function(event, ui) {
          var dragZIndex, draggableInformation, dropElement;
          dropElement = angular.element(ui.helper);
          originalZIndex = dropElement.css("z-index");
          dragZIndex = 10;
          if (typeof originalZIndex === "number") {
            dragZIndex += originalZIndex;
          }
          dropElement.css("z-index", dragZIndex);
          startShowDropAllowedState(dropElement);
          draggableInformation = collectDraggableInformation(dropElement, element);
          if (scope.objectDraggingStarted) {
            scope.objectDraggingStarted(draggableInformation, dropElement);
            scope.$apply();
          }
          if (scope.getDragAndDropTransferObject) {
            return setDragAndDropTransferObject(scope.getDragAndDropTransferObject(draggableInformation, dropElement));
          }
        };
        dragOptions.stop = function(event, ui) {
          var draggableInformation, dropElement, dropped;
          dropElement = angular.element(ui.helper);
          dropped = isDropped(dropElement);
          dropElement.css("z-index", originalZIndex);
          stopShowDropAllowedState(dropElement);
          draggableInformation = collectDraggableInformation(dropElement, element);
          if (!dropped) {
            if (scope.objectDroppedOutside) {
              scope.objectDroppedOutside(draggableInformation, dropElement);
              scope.$apply();
            }
          }
          if (scope.objectDraggingStopped) {
            scope.objectDraggingStopped(draggableInformation, dropElement);
          }
          return clearDragAndDropTransferObject();
        };
        element.draggable(dragOptions);
        return element.css("cursor", "move");
      }
    };
  };

  ut.commons.golabUtils.directive("draggable", [draggableDirective]);

  dummy = {
    acceptObjectDrop: null,
    objectDroppedInside: null
  };

  droppableDirective = function() {
    return {
      restrict: "A",
      link: function(scope, element, attrs) {
        var acceptDrop, objectDropped, objectEnter, objectLeave,
          _this = this;
        objectEnter = function(event, ui) {
          var dropElement;
          dropElement = angular.element(ui.helper);
          return showDropAllowedState(dropElement);
        };
        objectLeave = function(event, ui) {
          var dropElement;
          dropElement = angular.element(ui.helper);
          return showDropNotAllowedState(dropElement);
        };
        acceptDrop = function(draggableDirective) {
          var dropElement;
          if (scope.acceptObjectDrop) {
            dropElement = angular.element(draggableDirective);
            return scope.acceptObjectDrop(collectDraggableInformation(dropElement, element, attrs), dropElement, element);
          } else {
            return true;
          }
        };
        objectDropped = function(event, ui) {
          var dropElement, dropResult;
          dropElement = angular.element(ui.helper);
          if (scope.objectDroppedInside) {
            dropResult = scope.objectDroppedInside(collectDraggableInformation(dropElement, element, attrs), dropElement, element);
            if (dropResult) {
              event.stopPropagation();
            }
          }
          stopShowDropAllowedState(dropElement);
          return scope.$apply();
        };
        return element.droppable({
          over: function(event, ui) {
            return objectEnter(event, ui);
          },
          out: function(event, ui) {
            return objectLeave(event, ui);
          },
          accept: function(draggableDirective) {
            return acceptDrop(draggableDirective);
          },
          drop: function(event, ui) {
            return objectDropped(event, ui);
          },
          tolerance: "pointer"
        });
      }
    };
  };

  ut.commons.golabUtils.directive("droppable", [droppableDirective]);

}).call(this);

/*
//@ sourceMappingURL=dragAndDrop.map
*/
