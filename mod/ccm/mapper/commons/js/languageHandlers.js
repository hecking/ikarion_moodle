// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var LanguageHandler, OpenSocialLanguageHandler, StandAloneLanguageHandler, defaultLanguageFile, getErrorMessage, i, i_, indexFile, languagePath, loadFile, replaceRegExps,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.golab = this.golab || {};

  this.golab.common = this.golab.common || {};

  replaceRegExps = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i <= 10; i = ++_i) {
      _results.push(new RegExp("\\{" + i + "\\}", "g"));
    }
    return _results;
  })();

  i_ = "i_";

  LanguageHandler = (function() {
    function LanguageHandler() {}

    LanguageHandler.prototype.getMessage = function() {
      var arg, args, index, key, message, rawMessage, _i, _len;
      key = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      message = "";
      if (typeof key !== "undefined") {
        if (typeof key !== "string") {
          key = key.toString();
        }
        rawMessage = this.getMsg(key);
        message = rawMessage;
        if ((message != null)) {
          for (index = _i = 0, _len = args.length; _i < _len; index = ++_i) {
            arg = args[index];
            message = message.replace(replaceRegExps[index], arg);
          }
          if (message.match(replaceRegExps[index + 1])) {
            console.log("g4i18n: missing argument(s) for key '" + key + "', value '" + rawMessage + "', but only " + (arguments.length - 1) + " arguments given");
          }
        } else {
          console.log("g4i18n: missing value for key '" + key + "'");
          message = "???'" + key + "'???";
        }
      }
      return message;
    };

    LanguageHandler.prototype.getI_Message = function() {
      var args, key;
      key = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (key.toLowerCase().indexOf(i_) === 0) {
        return this.getMessage.apply(this, [key.substr(i_.length)].concat(__slice.call(args)));
      } else {
        return key;
      }
    };

    LanguageHandler.prototype.getMsg = function(key) {
      return console.error("this method must be overriden");
    };

    LanguageHandler.prototype.getLanguage = function() {
      return console.error("this method must be overriden");
    };

    return LanguageHandler;

  })();

  OpenSocialLanguageHandler = (function(_super) {
    __extends(OpenSocialLanguageHandler, _super);

    function OpenSocialLanguageHandler() {
      if ((typeof gadgets !== "undefined" && gadgets !== null)) {
        this.gadgetPrefs = new gadgets.Prefs();
        console.log("... running inside OpenSocial, using host local: " + (this.gadgetPrefs.getLang()));
      } else {
        throw "not running inside OpenSocial!";
      }
    }

    OpenSocialLanguageHandler.prototype.getMsg = function(key) {
      return this.gadgetPrefs.getMsg(key);
    };

    OpenSocialLanguageHandler.prototype.getLanguage = function() {
      return this.gadgetPrefs.getLang();
    };

    return OpenSocialLanguageHandler;

  })(LanguageHandler);

  loadFile = function(fileName, readyHandler, errorHandler) {
    var xhttp,
      _this = this;
    if (window.XMLHttpRequest) {
      xhttp = new XMLHttpRequest();
    } else {
      xhttp = new ActiveXObject("Microsoft.XMLHTTP");
    }
    xhttp.open("GET", fileName, true);
    xhttp.onload = function() {
      if (xhttp.readyState === 4 && xhttp.status === 200) {
        return readyHandler(xhttp);
      }
    };
    xhttp.onreadystatechange = function() {
      if (xhttp.readyState === 4 && xhttp.status !== 200) {
        return errorHandler(xhttp);
      }
    };
    return xhttp.send();
  };

  getErrorMessage = function(xhttp, filePath, fileType) {
    return "problems loading " + fileType + " file " + filePath + ", error: " + xhttp.status + " (" + xhttp.statusText + ")";
  };

  languagePath = "./languages/";

  indexFile = "list.txt";

  defaultLanguageFile = "ALL_ALL.xml";

  StandAloneLanguageHandler = (function(_super) {
    __extends(StandAloneLanguageHandler, _super);

    function StandAloneLanguageHandler(desiredLanguage, callback) {
      this.setLanguage = __bind(this.setLanguage, this);
      this.selectInitialLanguage = __bind(this.selectInitialLanguage, this);
      var _this = this;
      this.languageMap = {};
      this.languageFiles = {};
      this.currentLanguage = null;
      this.loadLanguageFileIndex(function() {
        return _this.selectInitialLanguage(desiredLanguage, callback);
      }, function(errorMessage) {
        console.error(errorMessage);
        return callback(null, _this);
      });
    }

    StandAloneLanguageHandler.prototype.loadLanguageFileIndex = function(readyHandler, errorHandler) {
      var indexFilePath,
        _this = this;
      indexFilePath = languagePath + indexFile;
      return loadFile(indexFilePath, function(xhttp) {
        var languageParts, line, lines, _i, _len;
        lines = xhttp.responseText.split("\n");
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          if (!(line.trim().length && line.trim() !== indexFile)) {
            continue;
          }
          languageParts = line.split("_");
          if (languageParts.length === 2) {
            _this.languageFiles[languageParts[0]] = line.trim();
          } else {
            console.error("can't understand language file name " + line);
          }
        }
        if (_this.languageFiles.length === 0) {
          console.error("could not find any language files in the language index file");
        } else if (!_this.languageFiles["ALL"]) {
          console.error("there is no ALL_*.xml file in the language index file");
        }
        console.log("found langauge files: " + (JSON.stringify(_this.languageFiles)));
        return readyHandler();
      }, function(xhttp) {
        return errorHandler(getErrorMessage(xhttp, indexFilePath, "index"));
      });
    };

    StandAloneLanguageHandler.prototype.getCurrentLanguage = function() {
      return this.currentLanguage;
    };

    StandAloneLanguageHandler.prototype.getLanguages = function() {
      var file, language, _ref, _results;
      _ref = this.languageFiles;
      _results = [];
      for (language in _ref) {
        file = _ref[language];
        if (language !== "ALL") {
          _results.push(language);
        }
      }
      return _results;
    };

    StandAloneLanguageHandler.prototype.selectInitialLanguage = function(desiredLanguage, callback) {
      if (this.languageFiles.length === 0) {
        this.languageMap = {};
        return setTimeout(callback, 0);
      } else {
        return this.setLanguage(desiredLanguage, callback);
      }
    };

    StandAloneLanguageHandler.prototype.setLanguage = function(language, callback) {
      var useLanguage;
      useLanguage = this.getSimpleLanguage(language);
      if (this.currentLanguage !== useLanguage) {
        if (!this.languageFiles[useLanguage]) {
          if (this.currentLanguage) {
            return;
          }
          useLanguage = "ALL";
        }
        return this.loadLanguageFile(this.languageFiles[useLanguage], useLanguage, callback);
      }
    };

    StandAloneLanguageHandler.prototype.getSimpleLanguage = function(language) {
      var languageParts;
      languageParts = language.split("-");
      return languageParts[0];
    };

    StandAloneLanguageHandler.prototype.loadLanguageFile = function(fileName, useLanguage, callback) {
      var languageFilePath,
        _this = this;
      languageFilePath = languagePath + fileName;
      return loadFile(languageFilePath, function(xhttp) {
        _this.parseLanguageFileContent(xhttp.responseText, languageFilePath, useLanguage);
        _this.currentLanguage = useLanguage;
        return callback(null, _this);
      }, function(xhttp) {
        return callback(getErrorMessage(xhttp, languageFilePath, "language"));
      });
    };

    StandAloneLanguageHandler.prototype.parseLanguageFileContent = function(xmlContent, languageFilePath, language) {
      var endKeyIndex, endKeyString, endValueIndex, endValueString, key, nrOfKeys, startKeyIndex, startKeyString, value;
      this.languageMap = {};
      nrOfKeys = 0;
      startKeyString = "<msg name=\"";
      endKeyString = "\">";
      endValueString = "</msg>";
      startKeyIndex = xmlContent.indexOf(startKeyString);
      while (startKeyIndex >= 0) {
        startKeyIndex += startKeyString.length;
        endKeyIndex = xmlContent.indexOf(endKeyString, startKeyIndex);
        if (endKeyIndex < 0) {
          console.log("failed to find end of key");
          startKeyIndex = -1;
        } else {
          endValueIndex = xmlContent.indexOf(endValueString, endKeyIndex);
          if (endValueIndex < 0) {
            console.log("failed to find end of key");
            startKeyIndex = -1;
          } else {
            key = xmlContent.slice(startKeyIndex, endKeyIndex).trim();
            value = xmlContent.slice(endKeyIndex + endKeyString.length, endValueIndex).trim();
            this.languageMap[key] = value;
            ++nrOfKeys;
            startKeyIndex = xmlContent.indexOf(startKeyString, endValueIndex + endValueString.length);
          }
        }
      }
      return console.log("loaded " + nrOfKeys + " keys from language file " + languageFilePath + ", for language " + language);
    };

    StandAloneLanguageHandler.prototype.getMsg = function(key) {
      return this.languageMap[key];
    };

    StandAloneLanguageHandler.prototype.getLanguage = function() {
      return this.currentLanguage;
    };

    return StandAloneLanguageHandler;

  })(LanguageHandler);

  window.golab.createLanguageHandler = function(desiredLanguage, callback) {
    if ((typeof gadgets !== "undefined" && gadgets !== null)) {
      return setTimeout(function() {
        return callback(null, new OpenSocialLanguageHandler());
      }, 0);
    } else {
      return new StandAloneLanguageHandler(desiredLanguage, callback);
    }
  };

}).call(this);

/*
//@ sourceMappingURL=languageHandlers.map
*/
