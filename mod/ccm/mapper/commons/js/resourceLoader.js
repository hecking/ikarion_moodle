// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  /*
    The resource loader can load resources at runtime. It is a wrapper around HeadJS and adds a kind of module definition system.
  
    If a path starts with a "/", it is assumed to be referencing the client root of the Twente Go-Lab directory setup.
    Only these paths, will be adjusted as needed. The resource loader support the following adjustments:
    - if running in shindig, the path adjusted to point to the correct path at the server where the gadget is fetched from
    - if the gadget path contains "/build/":
      - the "/build/" in the gadget path is the base url
      - its "flattens" the Twente Go-Lab directory setup, meaning it expects at the base url:
  	  - the commons and libs directories
  	  - the scripts, js, styles and css directories, with the files from all referenced labs, tools and web modules
  	- these changes match the creation of production build version of a lab or tool, as defined in the gulpfile.js in the client root.
  
    After this file has been loaded, the resource loader can be referenced by: window.golab.common.resourceLoader. The resource loader is a JavaScript object with the following properties:
  
    addResourcePaths: function(paths:Object, prefix: String): void
  
  	Adds one or more name/path combinations. This makes it possible to specify angular in your modules instead of using the path to angular.
  
  	paths: Object
  		The keys of the path objects are the names and the values are the paths. The Value is string.
  
  	prefix: String
  		The prefix is an optional parameter.
  		The prefix will be placed before the paths.
  
  
    addResourceModules: function(modules: Object, prefix: String): void
  
  	Adds one or more modules.
  
  	modules: Object
  		The keys of the modules objects are the names and the values are the definitions of the modules.
  		THe definition of a module is of type (String[])[].
  		The elements in the String[] can be:
  		- the name of a resource path (as defined with addResourcePaths)
  		- the name of a module (as defined with addResourceModules)
  		- the path of a resource
  
  	prefix: String
  		The prefix is an optional parameter.
  		The prefix will be placed before the paths.
  
    orderedLoad: function(resources: (String[])[]): void
  
  	Will load the resources in the specified sequence. The elements in the String[] will be loaded parallel.
  	The elements in the String[] can be:
  	- the name of a resource path (as defined with addResourcePaths)
  	- the name of a module (as defined with addResourceModules)
  	- the path of a resource
  	Any duplicate resources will only be loaded once.
  	When all resources are loaded, the callback function (given to the ready function) will be called.
  
    flatLoad: function(resources: (String[])[]): void
  
  	The flatLoad will do the same thing as the orderedLoad, except it will load all resources in parallel.
  
    ready: function(callback: function(): void): void
  
  	The callback function will be called when all resources are loaded by the orderLoad or flatLoad function
  
    getDesiredLanguage: function(): String
  
  	Returns the desired language, selected as follows:
  	If it is running inside shindig, the language as set in the open social container.
  	If it is running outside shindig:
  		1. the language specified in the url through the lang= option
  		2. the language of the browser
  
    getBaseUrl: function(): String
  
  	Returns the absolute url of the client directory in Twente Go-Lab directory setup
  
    getRootUrl: function(): String
  
  	Returns the absolute url of the directory of the gadget html/xml file
  
    getIncludeUrl: function(path: String): String
  
  	Returns the absolute url the resource referenced by path. If the gadget is running in shindig and IE9, the shindig proxy will be used.
  
  	path: String
  		The path to the resource. It is assumed to be relative to the root url.
  */

  var addPathPrefix, addResourceModules, addResourcePaths, baseUrl, buildPath, cleanupResourcesToLoad, countResources, createLoadList, cssExtension, debug, desiredLanguage, findDesiredLanguage, flattenResourceList, getBrowserLanguage, getIncludeUrl, getParameterFromUrl, getSimpleLanguage, head, limitNrOfParallelResources, loadCssFilesOneByOne, loadedResourceList, loadedResources, makeLoadCssFilesOneByOne, makeRealPath, makeRealPaths, minifiyPaths, orderedLoad, portPart, printFilesLoaded, printLoadList, productPaths, productionSubPaths, productionVersion, ready, realResourceList, registerLoadedResources, removeDuplicatesFromLoadList, resourceModules, resourcePaths, rootUrl, runningInGraasp, setBaseUrls, shindigProxy, showRealLoadList, startFlatLoad, startLoadMillis, startOrderedLoad, subPaths,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.golab = this.golab || {};

  this.golab.common = this.golab.common || {};

  head = window["head"];

  buildPath = "/build/";

  subPaths = ["/commons/", "/libs/", "/labs/", "/tools/", "/web/"];

  minifiyPaths = ["/libs/"];

  productPaths = ["/labs/", "/tools/", "/web/"];

  productionSubPaths = ["/scripts/", "/js/", "/styles/", "/css/"];

  loadCssFilesOneByOne = false;

  if (head.browser.ie && head.browser.version < 10) {
    loadCssFilesOneByOne = true;
  }

  loadCssFilesOneByOne = true;

  debug = true;

  showRealLoadList = debug || false;

  runningInGraasp = window.gadgets != null;

  productionVersion = false;

  baseUrl = "";

  rootUrl = "";

  setBaseUrls = function() {
    var findBaseUrl, findRootUrl, myUrl;
    findBaseUrl = function(url) {
      var buildPathIndex, lastIndex, subPath, subPathLastIndex, _i, _len;
      lastIndex = url.length;
      buildPathIndex = url.lastIndexOf(buildPath);
      if (buildPathIndex >= 0) {
        productionVersion = true;
        lastIndex = buildPathIndex + buildPath.length - 1;
      } else {
        for (_i = 0, _len = subPaths.length; _i < _len; _i++) {
          subPath = subPaths[_i];
          subPathLastIndex = url.lastIndexOf(subPath);
          if (subPathLastIndex >= 0) {
            lastIndex = Math.min(subPathLastIndex, lastIndex);
          }
        }
      }
      if (lastIndex < url.length) {
        return url.substr(0, lastIndex);
      } else {
        return "http://go-lab.gw.utwente.nl/sources";
      }
    };
    findRootUrl = function(rawUrl) {
      var lastSlashIndex, questionMarkIndex, url;
      questionMarkIndex = rawUrl.indexOf("?");
      url = questionMarkIndex >= 0 ? rawUrl.substring(0, questionMarkIndex) : rawUrl;
      lastSlashIndex = url.lastIndexOf("/");
      if (lastSlashIndex >= 0) {
        return url.substring(0, lastSlashIndex);
      } else {
        return url;
      }
    };
    myUrl = runningInGraasp ? window.gadgets.util.getUrlParameters().url : location.href;
    //myUrl = "http://localhost/moodle_plugin_ccm/trunk/conceptmap/src/main/webapp/conceptmapper_v1.html";
    baseUrl = findBaseUrl(myUrl);
    rootUrl = findRootUrl(myUrl);

    if (debug) {
      console.log("myUrl: " + myUrl);
    }
    if (debug) {
      console.log("baseUrl: " + baseUrl);
    }
    if (debug) {
      return console.log("rootUrl: " + rootUrl);
    }
  };

  setBaseUrls();

  getIncludeUrl = function(path) {
    var includeUrl;
    includeUrl = rootUrl + path;
    if (debug) {
      console.log("getIncludeUrl('" + path + "'): " + includeUrl);
    }
    return includeUrl;
  };

  if (runningInGraasp && head.browser.ie && head.browser.version < 10) {
    portPart = window.location.port;
    if (portPart) {
      portPart = ":" + portPart;
    }
    shindigProxy = "" + window.location.protocol + "//" + window.location.host + portPart + "/gadgets/proxy/";
    if (debug) {
      console.log("shindigProxy: " + shindigProxy);
    }
    getIncludeUrl = function(path) {
      var fileName, includeUrl, lastSlashIndex;
      lastSlashIndex = path.lastIndexOf("/");
      fileName = lastSlashIndex >= 0 ? path.substr(lastSlashIndex + 1) : path;
      includeUrl = shindigProxy + fileName + "?container=default&url=" + rootUrl + path;
      if (true) {
        console.log("getIncludeUrl('" + path + "'): " + includeUrl);
      }
      return includeUrl;
    };
  }

  resourcePaths = {};

  resourceModules = {};

  loadedResources = {};

  loadedResourceList = [];

  addPathPrefix = function(paths, prefix) {
    var key, path, prefixedPaths, _i, _len, _results;
    if (prefix) {
      if (Array.isArray(paths)) {
        _results = [];
        for (_i = 0, _len = paths.length; _i < _len; _i++) {
          path = paths[_i];
          _results.push(addPathPrefix(path, prefix));
        }
        return _results;
      } else if (typeof paths === "object") {
        prefixedPaths = {};
        for (key in paths) {
          path = paths[key];
          prefixedPaths[key] = addPathPrefix(path, prefix);
        }
        return prefixedPaths;
      } else {
        return prefix + paths;
      }
    } else {
      return paths;
    }
  };

  addResourcePaths = function(paths, prefix) {
    var key, prefixedPaths, value;
    prefixedPaths = addPathPrefix(paths, prefix);
    for (key in prefixedPaths) {
      value = prefixedPaths[key];
      resourcePaths[key] = value;
    }
    if (debug) {
      return console.log("resourcePaths: " + (JSON.stringify(resourcePaths)));
    }
  };

  addResourceModules = function(modules, prefix) {
    var key, prefixedModules, value;
    prefixedModules = addPathPrefix(modules, prefix);
    for (key in prefixedModules) {
      value = prefixedModules[key];
      resourceModules[key] = value;
    }
    if (debug) {
      return console.log("resourceModules: " + (JSON.stringify(resourceModules)));
    }
  };

  makeRealPath = function(path) {
    var lastIndex, lastJsIndex, localPath, productPath, productionSubPath, subPath, _i, _j, _k, _len, _len1, _len2;
    if (productionVersion) {
      for (_i = 0, _len = productPaths.length; _i < _len; _i++) {
        productPath = productPaths[_i];
        if (path.indexOf(productPath) === 0) {
          for (_j = 0, _len1 = productionSubPaths.length; _j < _len1; _j++) {
            productionSubPath = productionSubPaths[_j];
            lastIndex = path.lastIndexOf(productionSubPath);
            if (lastIndex >= 0) {
              localPath = path.substring(lastIndex);
              return baseUrl + localPath;
            }
          }
        }
      }
    }
    for (_k = 0, _len2 = subPaths.length; _k < _len2; _k++) {
      subPath = subPaths[_k];
      if (path.indexOf(subPath) === 0) {
        if (productionVersion && __indexOf.call(minifiyPaths, subPath) >= 0) {
          lastJsIndex = path.lastIndexOf(".js");
          if (lastJsIndex >= 0) {
            path = path.substring(0, lastJsIndex) + ".min.js";
          }
        }
        return baseUrl + path;
      }
    }
    return path;
  };

  makeRealPaths = function(paths) {
    var path, _i, _len, _results;
    if (Array.isArray(paths)) {
      _results = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        _results.push(makeRealPath(path));
      }
      return _results;
    } else {
      return makeRealPath(paths);
    }
  };

  cleanupResourcesToLoad = function(resourcesToLoad) {
    var realfilesToLoad, resource, _i, _len;
    realfilesToLoad = [];
    for (_i = 0, _len = resourcesToLoad.length; _i < _len; _i++) {
      resource = resourcesToLoad[_i];
      if (loadedResources[resource]) {
        if (debug) {
          console.log("allready loaded: " + resource);
        }
      } else if (resourcePaths[resource]) {
        realfilesToLoad.push(resourcePaths[resource]);
      } else {
        realfilesToLoad.push(resource);
      }
    }
    return realfilesToLoad;
  };

  registerLoadedResources = function(filesToLoad) {
    var file, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = filesToLoad.length; _i < _len; _i++) {
      file = filesToLoad[_i];
      loadedResources[file] = true;
      _results.push(loadedResourceList.push(file));
    }
    return _results;
  };

  orderedLoad = function(resourcesList) {
    var loadNextResources, nextResourcesList, realFilePaths, resourcesToLoad, startLoadMillis;
    if (debug) {
      console.log("orderedLoad(" + (JSON.stringify(resourcesList)) + ")");
    }
    if (resourcesList.length) {
      resourcesToLoad = resourcesList[0];
      nextResourcesList = resourcesList.length > 1 ? resourcesList.slice(1) : [];
      startLoadMillis = Date.now();
      loadNextResources = function() {
        var usedLoadMillis;
        usedLoadMillis = Date.now() - startLoadMillis;
        if (debug) {
          console.log("loaded: " + resourcesToLoad + " in " + usedLoadMillis + " ms.");
        }
        return orderedLoad(nextResourcesList);
      };
      resourcesToLoad = cleanupResourcesToLoad(resourcesToLoad);
      if (resourcesToLoad.length) {
        registerLoadedResources(resourcesToLoad);
        realFilePaths = makeRealPaths(resourcesToLoad);
        if (debug) {
          console.log("loading: " + (JSON.stringify(resourcesToLoad)));
        }
        if (debug) {
          console.log("real paths: " + (JSON.stringify(realFilePaths)));
        }
        return head.load(realFilePaths, loadNextResources);
      } else {
        return loadNextResources();
      }
    }
  };

  createLoadList = function(resourcesList) {
    var list, loadList, res, resource, resourceList, resources, _i, _j, _k, _len, _len1, _len2, _ref;
    loadList = [];
    for (_i = 0, _len = resourcesList.length; _i < _len; _i++) {
      resources = resourcesList[_i];
      list = [];
      for (_j = 0, _len1 = resources.length; _j < _len1; _j++) {
        resource = resources[_j];
        if (resourceModules[resource]) {
          resourceList = createLoadList(resourceModules[resource]);
          if (resourceList.length === 1) {
            _ref = resourceList[0];
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
              res = _ref[_k];
              list.push(res);
            }
          } else {
            loadList = loadList.concat(resourceList);
          }
        } else {
          list.push(resource);
        }
      }
      if (list.length) {
        loadList.push(list);
      }
    }
    if (debug) {
      console.log("loadList: " + (JSON.stringify(loadList)));
    }
    return loadList;
  };

  removeDuplicatesFromLoadList = function(resourcesList) {
    var cleanedLoadList, list, listedResources, resource, resources, _i, _j, _len, _len1;
    listedResources = {};
    cleanedLoadList = [];
    for (_i = 0, _len = resourcesList.length; _i < _len; _i++) {
      resources = resourcesList[_i];
      list = [];
      for (_j = 0, _len1 = resources.length; _j < _len1; _j++) {
        resource = resources[_j];
        if (!listedResources[resource]) {
          list.push(resource);
          listedResources[resource] = true;
        }
      }
      if (list.length) {
        cleanedLoadList.push(list);
      }
    }
    return cleanedLoadList;
  };

  cssExtension = ".css";

  makeLoadCssFilesOneByOne = function(resourceList) {
    var isCssResource, loadList, noCssResourceList, resource, resources, _i, _j, _len, _len1;
    isCssResource = function(resource) {
      var cssIndex;
      cssIndex = resource.toLowerCase().lastIndexOf(".css");
      return cssIndex === resource.length - cssExtension.length;
    };
    loadList = [];
    for (_i = 0, _len = resourceList.length; _i < _len; _i++) {
      resources = resourceList[_i];
      noCssResourceList = [];
      for (_j = 0, _len1 = resources.length; _j < _len1; _j++) {
        resource = resources[_j];
        if (isCssResource(resource)) {
          loadList.push([resource]);
        } else {
          noCssResourceList.push(resource);
        }
      }
      if (noCssResourceList.length) {
        loadList.push(noCssResourceList);
      }
    }
    return loadList;
  };

  limitNrOfParallelResources = function(resourceList) {
    var loadList, maxNrOfParallelResources, nrOfResourcesCopied, nrOfResourcesToCopy, resources, _i, _len;
    maxNrOfParallelResources = 16;
    loadList = [];
    for (_i = 0, _len = resourceList.length; _i < _len; _i++) {
      resources = resourceList[_i];
      nrOfResourcesCopied = 0;
      while (nrOfResourcesCopied < resources.length) {
        nrOfResourcesToCopy = Math.min(maxNrOfParallelResources, resources.length - nrOfResourcesCopied);
        loadList.push(resources.slice(nrOfResourcesCopied, nrOfResourcesCopied + nrOfResourcesToCopy));
        nrOfResourcesCopied += nrOfResourcesToCopy;
      }
    }
    return loadList;
  };

  countResources = function(resourceList) {
    var count, resources, _i, _len;
    count = 0;
    for (_i = 0, _len = resourceList.length; _i < _len; _i++) {
      resources = resourceList[_i];
      count += resources.length;
    }
    return count;
  };

  printLoadList = function(header, resourcesList) {
    var index, item, list, _i, _j, _len, _len1, _results;
    console.log(header);
    _results = [];
    for (index = _i = 0, _len = realResourceList.length; _i < _len; index = ++_i) {
      list = realResourceList[index];
      console.log(" " + (index + 1) + ": [ (" + list.length + " resources)");
      for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
        item = list[_j];
        console.log("     " + item);
      }
      _results.push(console.log("    ]"));
    }
    return _results;
  };

  startLoadMillis = Date.now();

  realResourceList = [];

  startOrderedLoad = function(resources) {
    var loadList;
    loadList = createLoadList(resources);
    loadList = removeDuplicatesFromLoadList(loadList);
    if (loadCssFilesOneByOne) {
      loadList = makeLoadCssFilesOneByOne(loadList);
    }
    realResourceList = limitNrOfParallelResources(loadList);
    if (showRealLoadList) {
      printLoadList("The real resource list:", realResourceList);
    }
    console.log("Start ordered loading " + (countResources(realResourceList)) + " files in " + realResourceList.length + " steps");
    return orderedLoad(realResourceList);
  };

  printFilesLoaded = function() {
    var file, index, _i, _len, _results;
    console.log("Loaded " + loadedResourceList.length + " files:");
    _results = [];
    for (index = _i = 0, _len = loadedResourceList.length; _i < _len; index = ++_i) {
      file = loadedResourceList[index];
      _results.push(console.log(" " + (index + 1) + ": " + file));
    }
    return _results;
  };

  flattenResourceList = function(resourceList) {
    var loadList, resource, resources, _i, _j, _len, _len1;
    loadList = [];
    for (_i = 0, _len = resourceList.length; _i < _len; _i++) {
      resources = resourceList[_i];
      for (_j = 0, _len1 = resources.length; _j < _len1; _j++) {
        resource = resources[_j];
        loadList.push(resource);
      }
    }
    return [loadList];
  };

  startFlatLoad = function(resources) {
    var loadList;
    loadList = createLoadList(resources);
    loadList = removeDuplicatesFromLoadList(loadList);
    realResourceList = flattenResourceList(loadList);
    if (loadCssFilesOneByOne) {
      realResourceList = makeLoadCssFilesOneByOne(realResourceList);
    }
    if (showRealLoadList) {
      printLoadList("The real resource list:", realResourceList);
    }
    console.log("Start flat loading " + (countResources(realResourceList)) + " files in " + realResourceList.length + " steps");
    return orderedLoad(realResourceList);
  };

  ready = function(callback) {
    return head.ready(function() {
      var difference, nrOfResourcesToLoad, usedLoadMillis;
      usedLoadMillis = Date.now() - startLoadMillis;
      nrOfResourcesToLoad = countResources(realResourceList);
      difference = nrOfResourcesToLoad - loadedResourceList.length;
      if (difference) {
        console.error("did not load all resources, missed " + difference + " resources");
        if (!showRealLoadList) {
          printLoadList("The real resource list:", realResourceList);
        }
      }
      console.log("Loaded " + loadedResourceList.length + " files, in " + usedLoadMillis + " ms.");
      if (debug || difference) {
        printFilesLoaded();
      }
      return callback();
    });
  };

  getParameterFromUrl = function(key) {
    var lcKey, parameter, part, partParts, parts, queryPart, _i, _len;
    lcKey = key.toLowerCase();
    parameter = null;
    queryPart = location.search.trim().toLowerCase();
    if (queryPart && queryPart[0] === "?") {
      parts = queryPart.substring(1).split("&");
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        partParts = part.split("=");
        if (partParts.length === 2 && partParts[0] === lcKey) {
          parameter = partParts[1];
        }
      }
    }
    return parameter;
  };

  getBrowserLanguage = function() {
    if (navigator.userLanguage) {
      return navigator.userLanguage;
    } else if (navigator.language) {
      return navigator.language;
    } else {
      return "en";
    }
  };

  findDesiredLanguage = function() {
    var gadgetPrefs, language;
    if (runningInGraasp) {
      gadgetPrefs = new gadgets.Prefs();
      return gadgetPrefs.getLang();
    } else {
      language = getParameterFromUrl("lang");
      if (language) {
        return language;
      } else {
        return getBrowserLanguage();
      }
    }
  };

  getSimpleLanguage = function(language) {
    var languageParts;
    languageParts = language.split("-");
    return languageParts[0];
  };

  desiredLanguage = findDesiredLanguage();

  this.golab.common.resourceLoader = {
    addResourcePaths: addResourcePaths,
    addResourceModules: addResourceModules,
    orderedLoad: startOrderedLoad,
    flatLoad: startFlatLoad,
    ready: ready,
    getDesiredLanguage: function() {
      return desiredLanguage;
    },
    getBaseUrl: function() {
      return baseUrl;
    },
    getRootUrl: function() {
      return rootUrl;
    },
    getIncludeUrl: getIncludeUrl
  };

}).call(this);

/*
//@ sourceMappingURL=resourceLoader.map
*/
